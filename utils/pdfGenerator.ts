
import { jsPDF, jsPDFOptions } from 'jspdf';
import autoTable from 'jspdf-autotable';
import html2canvas from 'html2canvas';
import { Student, SchoolDetails } from '../types';
import { CATEGORY_OPTIONS } from '../constants';

export const generatePdfFromElement = async (elementId: string, filename: string, orientation: 'p' | 'l' = 'p') => {
    const input = document.getElementById(elementId);
    if (!input) {
        console.error(`Element with id ${elementId} not found.`);
        return;
    }

    const canvas = await html2canvas(input, {
        scale: 2, // Higher resolution for better quality
        useCORS: true,
        logging: false,
    });

    const imgData = canvas.toDataURL('image/png');
    
    const pdfOptions: jsPDFOptions = {
        orientation,
        unit: 'mm',
        format: 'a4'
    };
    const pdf = new jsPDF(pdfOptions);
    
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();
    
    pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
    pdf.save(`${filename}.pdf`);
};

export const generateMultiPagePdfFromElements = async (elementIds: string[], filename: string) => {
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();

    for (let i = 0; i < elementIds.length; i++) {
        const elementId = elementIds[i];
        const input = document.getElementById(elementId);
        if (!input) {
            console.error(`Element with id ${elementId} not found.`);
            continue;
        }

        if (i > 0) {
            pdf.addPage();
        }

        const canvas = await html2canvas(input, { scale: 2, useCORS: true, logging: false });
        const imgData = canvas.toDataURL('image/png');
        
        pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
    }

    pdf.save(`${filename}.pdf`);
};

const addHeader = (doc: jsPDF, schoolDetails: SchoolDetails) => {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text(schoolDetails.name, doc.internal.pageSize.getWidth() / 2, 15, { align: 'center' });

    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(schoolDetails.address, doc.internal.pageSize.getWidth() / 2, 22, { align: 'center' });
};

const addFooter = (doc: jsPDF, studentName?: string) => {
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        const footerText = `Page ${i} of ${pageCount} | Generated for ${studentName || ''} on: ${new Date().toLocaleDateString()}`;
        doc.text(footerText, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
        doc.text(`Generated by School Management Pro V2`, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 5, { align: 'center' });
    }
}

export const generateRollStatementVectorPdf = async (
    students: Student[],
    className: string,
    schoolDetails: SchoolDetails,
    filename: string
) => {
    const doc = new jsPDF();
    addHeader(doc, schoolDetails);
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(`Roll Statement - Class ${className}`, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });
    
    const tableColumn = ["Roll No", "Admission No", "Student Name", "Father's Name", "Category", "D.O.B"];
    const tableRows: (string | number | undefined | null)[][] = [];

    students.forEach(student => {
        const studentData = [
            student.rollNo,
            student.admissionNo,
            student.name,
            student.fathersName,
            student.category || 'N/A',
            student.dob,
        ];
        tableRows.push(studentData);
    });

    autoTable(doc, {
        head: [tableColumn],
        body: tableRows,
        startY: 35,
        theme: 'grid',
        headStyles: { fillColor: [22, 160, 133] },
    });
    
    addFooter(doc, `Class ${className}`);
    doc.save(`${filename}.pdf`);
};

export const generateCategoryRollStatementVectorPdf = async (
    students: Student[],
    className: string,
    schoolDetails: SchoolDetails,
    filename: string
) => {
    const doc = new jsPDF();
    addHeader(doc, schoolDetails);
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(`Gender & Category Wise Roll Statement - Class ${className}`, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });

    const GENDERS: ('Male' | 'Female' | 'Other')[] = ['Male', 'Female', 'Other'];
    const summary: { [category: string]: { [gender: string]: number } } = {};
    CATEGORY_OPTIONS.forEach(cat => {
        summary[cat] = { Male: 0, Female: 0, Other: 0 };
    });

    students.forEach(student => {
        const category = student.category && CATEGORY_OPTIONS.includes(student.category) ? student.category : 'General';
        const gender = student.gender;
        if (summary[category] && GENDERS.includes(gender)) {
            summary[category][gender]++;
        }
    });
    
    const head = [['Category', ...GENDERS, 'Total']];
    const body = CATEGORY_OPTIONS.map(category => {
        const counts = summary[category];
        const total = counts.Male + counts.Female + counts.Other;
        return [category, counts.Male, counts.Female, counts.Other, total];
    });

    const genderTotals = GENDERS.map(gender => CATEGORY_OPTIONS.reduce((acc, cat) => acc + (summary[cat]?.[gender] || 0), 0));
    const grandTotal = students.length;
    const foot = [['Total', ...genderTotals, grandTotal]];

    autoTable(doc, {
        head,
        body,
        foot,
        startY: 35,
        theme: 'grid',
        headStyles: { fillColor: [22, 160, 133], textColor: [255, 255, 255] },
        footStyles: { fillColor: [22, 160, 133], textColor: [255, 255, 255], fontStyle: 'bold' }
    });
    
    addFooter(doc, `Class ${className}`);
    doc.save(`${filename}.pdf`);
};
