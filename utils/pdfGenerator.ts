
import { jsPDF } from 'jspdf';
// FIX: Use functional import for jspdf-autotable to align with recommended TypeScript usage.
import autoTable from 'jspdf-autotable';
import html2canvas from 'html2canvas';
import { Student, SchoolDetails } from '../types';
import { CATEGORY_OPTIONS, CLASS_OPTIONS } from '../constants';

// FIX: Removed manual module augmentation for 'jspdf' as it caused an error. 
// The functional import of `autoTable` provides the necessary types.

// NEW: Generic function to generate single-page PDF from an HTML element using html2canvas
export const generatePdfFromElement = async (elementId: string, filename: string) => {
    const input = document.getElementById(elementId);
    if (!input) {
        console.error(`Element with id ${elementId} not found.`);
        return;
    }

    const canvas = await html2canvas(input, {
        scale: 2, // Higher resolution for better quality
        useCORS: true,
        logging: false,
    });

    const imgData = canvas.toDataURL('image/png');
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();
    
    pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
    pdf.save(`${filename}.pdf`);
};

// NEW: Generic function to generate multi-page PDF from HTML elements using html2canvas
export const generateMultiPagePdfFromElements = async (elementIds: string[], filename: string) => {
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();

    for (let i = 0; i < elementIds.length; i++) {
        const elementId = elementIds[i];
        const input = document.getElementById(elementId);
        if (!input) {
            console.error(`Element with id ${elementId} not found.`);
            continue;
        }

        if (i > 0) {
            pdf.addPage();
        }

        const canvas = await html2canvas(input, { scale: 2, useCORS: true, logging: false });
        const imgData = canvas.toDataURL('image/png');
        
        pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
    }

    pdf.save(`${filename}.pdf`);
};

const addHeader = (doc: jsPDF, schoolDetails: SchoolDetails) => {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text(schoolDetails.name, doc.internal.pageSize.getWidth() / 2, 15, { align: 'center' });

    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(schoolDetails.address, doc.internal.pageSize.getWidth() / 2, 22, { align: 'center' });
};

const addFooter = (doc: jsPDF, studentName?: string) => {
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        const footerText = `Page ${i} of ${pageCount} | Generated for ${studentName || ''} on: ${new Date().toLocaleDateString()}`;
        doc.text(footerText, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
        doc.text(`Generated by School Management Pro V2`, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 5, { align: 'center' });
    }
}

export const generateRollStatementVectorPdf = async (
    students: Student[],
    className: string,
    schoolDetails: SchoolDetails,
    filename: string
) => {
    const doc = new jsPDF();
    addHeader(doc, schoolDetails);
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(`Roll Statement - Class ${className}`, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });
    
    const tableColumn = ["Roll No", "Admission No", "Student Name", "Father's Name", "Category", "D.O.B"];
    const tableRows: (string | number | undefined | null)[][] = [];

    students.forEach(student => {
        const studentData = [
            student.rollNo,
            student.admissionNo,
            student.name,
            student.fathersName,
            student.category || 'N/A',
            student.dob,
        ];
        tableRows.push(studentData);
    });

    autoTable(doc, {
        head: [tableColumn],
        body: tableRows,
        startY: 35,
        theme: 'grid',
        headStyles: { fillColor: [22, 160, 133] },
    });
    
    addFooter(doc, `Class ${className}`);
    doc.save(`${filename}.pdf`);
};

export const generateCategoryRollStatementPdf = async (students: Student[], className: string, schoolDetails: SchoolDetails) => {
    const doc = new jsPDF();
    const GENDERS = ['Male', 'Female', 'Other'];

    const summary: { [category: string]: { [gender: string]: number } } = {};
    CATEGORY_OPTIONS.forEach(cat => {
        summary[cat] = { Male: 0, Female: 0, Other: 0 };
    });

    students.forEach(student => {
        const category = student.category && CATEGORY_OPTIONS.includes(student.category) ? student.category : 'General';
        const gender = student.gender && GENDERS.includes(student.gender) ? student.gender : 'Other';
        if (summary[category]) {
            summary[category][gender]++;
        }
    });

    addHeader(doc, schoolDetails);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(`Gender & Category Wise Roll Statement - Class ${className}`, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });

    const head = [['Category', ...GENDERS, 'Total']];
    const body = CATEGORY_OPTIONS.map(category => {
        const counts = summary[category];
        const total = counts.Male + counts.Female + counts.Other;
        return [category, counts.Male, counts.Female, counts.Other, total];
    });

    const genderTotals = GENDERS.map(gender => CATEGORY_OPTIONS.reduce((acc, cat) => acc + summary[cat][gender], 0));
    const grandTotal = students.length;
    const foot = [['Total', ...genderTotals, grandTotal]];

    autoTable(doc, {
        head,
        body,
        foot,
        startY: 35,
        theme: 'grid',
        headStyles: { fillColor: '#c7ecee' },
        footStyles: { fillColor: '#c7ecee', fontStyle: 'bold' }
    });

    doc.save(`Category-Roll-Statement-${className}.pdf`);
};

export const generateConsolidatedRollStatementPdf = async (
    studentsByClass: Map<string, Student[]>,
    schoolDetails: SchoolDetails,
    session: string
) => {
    const doc = new jsPDF({ orientation: 'landscape' });
    const GENDERS = ['M', 'F', 'O', 'T']; // Male, Female, Other, Total

    addHeader(doc, schoolDetails);
    doc.setFontSize(12);
    doc.text(`Consolidated Category & Gender Wise Roll Statement - Session ${session}`, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });

    // Build Headers
    const headerRow1 = [
        { content: 'Class', rowSpan: 2, styles: { valign: 'middle', halign: 'center' } },
        ...CATEGORY_OPTIONS.map(cat => ({ content: cat, colSpan: 4, styles: { halign: 'center' } })),
        { content: 'Grand Total', colSpan: 4, styles: { halign: 'center' } }
    ];

    const headerRow2: string[] = [];
    // For Categories
    CATEGORY_OPTIONS.forEach(() => headerRow2.push(...GENDERS));
    // For Grand Total
    headerRow2.push(...GENDERS);

    // Prepare Data
    const classNames = Array.from(studentsByClass.keys()).sort((a, b) => {
        const indexA = CLASS_OPTIONS.indexOf(a);
        const indexB = CLASS_OPTIONS.indexOf(b);
        if (indexA !== -1 && indexB !== -1) return indexA - indexB;
        return a.localeCompare(b, undefined, { numeric: true });
    });

    const body = classNames.map(className => {
        const students = studentsByClass.get(className) || [];
        const rowData: (number | string)[] = [className];
        
        let classMaleTotal = 0;
        let classFemaleTotal = 0;
        let classOtherTotal = 0;

        // Count per Category
        CATEGORY_OPTIONS.forEach(cat => {
            const catStudents = students.filter(s => (s.category || 'General') === cat);
            const m = catStudents.filter(s => s.gender === 'Male').length;
            const f = catStudents.filter(s => s.gender === 'Female').length;
            const o = catStudents.filter(s => s.gender === 'Other' || !s.gender).length;
            const t = m + f + o;

            classMaleTotal += m;
            classFemaleTotal += f;
            classOtherTotal += o;

            rowData.push(m || '', f || '', o || '', t || '');
        });

        // Grand Totals for Class
        rowData.push(classMaleTotal, classFemaleTotal, classOtherTotal, classMaleTotal + classFemaleTotal + classOtherTotal);
        return rowData;
    });

    // Footer Calculation (Total of columns)
    const footerRow = ['TOTAL'];
    for (let i = 1; i < headerRow2.length + 1; i++) { // +1 because of 'Class' column
        let colSum = 0;
        body.forEach(row => {
            const val = Number(row[i]);
            if (!isNaN(val)) colSum += val;
        });
        footerRow.push(String(colSum));
    }

    autoTable(doc, {
        head: [headerRow1, headerRow2],
        body: body,
        foot: [footerRow],
        startY: 35,
        theme: 'grid',
        styles: { fontSize: 8, cellPadding: 1, halign: 'center' },
        headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold', lineWidth: 0.1, lineColor: 0 },
        footStyles: { fillColor: [200, 200, 200], textColor: 0, fontStyle: 'bold' },
        tableLineColor: 0,
        tableLineWidth: 0.1,
    });

    doc.save(`Consolidated-Roll-Statement-${session}.pdf`);
};
